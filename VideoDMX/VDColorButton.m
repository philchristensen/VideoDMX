//
//  VDColorButton.m
//  VideoDMX
//
//  Created by Phil Christensen on 2/3/14.
//  Copyright (c) 2014 bubblehouse. All rights reserved.
//

#import "VDColorButton.h"

@implementation VDColorButton

-(void)detectColorAt:(CGPoint)point inImage:(NSImage*)image {
    NSBitmapImageRep* raw_img = [NSBitmapImageRep imageRepWithData:[image TIFFRepresentation]];
    self.currentColor = [raw_img colorAtX:point.x y:point.y];
    [self setWantsLayer:YES];
    [self performSelectorOnMainThread:@selector(updateDisplay)
                           withObject:nil
                        waitUntilDone:YES];
}

-(void)updateDisplay {
    [self setNeedsDisplay:YES];
}

-(void)drawRect:(NSRect)dirtyRect {
    NSBezierPath* ovalPath = [NSBezierPath bezierPathWithOvalInRect: NSMakeRect(0.5, 0.5, 15, 15)];
    [self.currentColor setFill];
    [ovalPath fill];
    [[NSColor blackColor] setStroke];
    [ovalPath setLineWidth: 1];
    [ovalPath stroke];
}

- (NSRect)calculatedItemBounds {
    NSRect calculatedRect;
    
    // calculate the bounds of the draggable item
    // relative to the location
    calculatedRect.origin=self.location;

    // the example assumes that the width and height
    // are fixed values
    calculatedRect.size.width=15.0;
    calculatedRect.size.height=15.0;
    
    return calculatedRect;
}

- (BOOL)acceptsFirstResponder {
    return YES;
}

-(void)mouseDown:(NSEvent *)event {
    NSPoint clickLocation;
    BOOL itemHit=NO;
    
    // convert the mouse-down location into the view coords
    clickLocation = [self convertPoint:[event locationInWindow]
                              fromView:nil];
    
    // did the mouse-down occur in the item?
    itemHit = [self isPointInItem:clickLocation];
    
    // Yes it did, note that we're starting to drag
    if (itemHit) {
        // flag the instance variable that indicates
        // a drag was actually started
        self.dragging=YES;
        
        // store the starting mouse-down location;
        self.lastDragLocation=clickLocation;
        
        // set the cursor to the closed hand cursor
        // for the duration of the drag
        [[NSCursor closedHandCursor] push];
    }
}

- (BOOL)isPointInItem:(NSPoint)testPoint {
    BOOL itemHit=NO;
    
    // test first if we're in the rough bounds
    itemHit = NSPointInRect(testPoint,[self calculatedItemBounds]);
    
    // yes, lets further refine the testing
    if (itemHit) {
        // if this was a non-rectangular shape, you would refine
        // the hit testing here
    }
    
    return itemHit;
}

-(void)mouseDragged:(NSEvent *)event{
    if (self.dragging) {
        NSPoint newDragLocation=[self convertPoint:[event locationInWindow]
                                          fromView:nil];
        
        
        // offset the item by the change in mouse movement
        // in the event
        [self offsetLocationByX:(newDragLocation.x-self.lastDragLocation.x)
                           andY:(newDragLocation.y-self.lastDragLocation.y)];
        
        // save the new drag location for the next drag event
        self.lastDragLocation=newDragLocation;
        
        // support automatic scrolling during a drag
        // by calling NSView's autoscroll: method
        [self autoscroll:event];
    }
}

- (void)offsetLocationByX:(float)x andY:(float)y {
    // tell the display to redraw the old rect
    [self setNeedsDisplayInRect:[self calculatedItemBounds]];
    
    // since the offset can be generated by both mouse moves
    // and moveUp:, moveDown:, etc.. actions, we'll invert
    // the deltaY amount based on if the view is flipped or
    // not.
    int invertDeltaY = [self isFlipped] ? -1: 1;
    
    self.location = CGPointMake(self.location.x+x, self.location.y+y*invertDeltaY);
    
    // invalidate the new rect location so that it'll
    // be redrawn
    [self setNeedsDisplayInRect:[self calculatedItemBounds]];
    
}

-(void)mouseUp:(NSEvent *)event {
    self.dragging=NO;
    
    // finished dragging, restore the cursor
    [NSCursor pop];
    
    // the item has moved, we need to reset our cursor
    // rectangle
    [[self window] invalidateCursorRectsForView:self];
}

@end
